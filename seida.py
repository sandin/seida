import re
import xmlrpc.client
import ida_idaapi
import ida_kernwin
import idautils
import idc

SEIDA_USE_AS_SCRIPT = True
SEIDA_SERVER_ADDR = "http://10.37.129.2:50052"  # TODO

seida = None  # global export API
START_EXEC_ACTION_NAME = "execution:start_exec"
STEP_INST_ACTION_NAME = "execution:step_inst"
STEP_BLOCK_ACTION_NAME = "execution:step_block"
STEP_TO_ACTION_NAME = "execution:step_to"
ICON_START = bytes([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF,
    0x61, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
    0x00, 0xE9, 0x49, 0x44, 0x41, 0x54, 0x38, 0x4F, 0xA5, 0x93, 0x3B, 0x0A, 0xC2, 0x40, 0x10, 0x86,
    0xBF, 0x59, 0x4B, 0x1B, 0x8F, 0xE0, 0x11, 0x04, 0x1F, 0xA9, 0x3D, 0x86, 0x60, 0xA2, 0xBD, 0xB5,
    0x9D, 0x47, 0xF0, 0x00, 0xC1, 0xCA, 0x68, 0x91, 0xD2, 0x42, 0xAF, 0xA0, 0xA0, 0x16, 0x1E, 0xC1,
    0x23, 0x58, 0xF8, 0x0A, 0x58, 0x8C, 0xE0, 0x8B, 0xB8, 0x44, 0x8D, 0x64, 0x61, 0x60, 0x61, 0x77,
    0xBE, 0x99, 0xF9, 0xF7, 0x5F, 0x21, 0xE3, 0x92, 0x8C, 0xF9, 0xBC, 0x03, 0x96, 0xEB, 0x06, 0x4E,
    0x35, 0xFC, 0x07, 0x6A, 0x01, 0x56, 0x73, 0x20, 0x0F, 0xB9, 0x1E, 0x4E, 0x79, 0x96, 0x06, 0x64,
    0x03, 0x36, 0x40, 0xE9, 0x96, 0x28, 0x4C, 0xD1, 0xDC, 0xE0, 0x17, 0xC8, 0x06, 0x6C, 0x81, 0xA2,
    0x55, 0x79, 0x82, 0xD0, 0xA7, 0x56, 0x5B, 0x24, 0x75, 0x64, 0x03, 0x76, 0x40, 0x21, 0xB9, 0x75,
    0xF5, 0x39, 0x9D, 0xBA, 0xD4, 0xEB, 0x87, 0xF8, 0xB9, 0x0D, 0x50, 0xE0, 0x7C, 0x0B, 0x25, 0x42,
    0x1E, 0x7B, 0x88, 0x80, 0xCB, 0x3D, 0x4C, 0x88, 0x53, 0xF1, 0x9F, 0x90, 0x77, 0x40, 0x30, 0x8A,
    0x01, 0x34, 0x42, 0xE4, 0x0E, 0x7B, 0x01, 0xE4, 0x82, 0x68, 0x88, 0xE7, 0x7D, 0x04, 0x7C, 0x1E,
    0x41, 0xF1, 0x39, 0xEE, 0xBB, 0x74, 0x3A, 0x5F, 0x46, 0x08, 0x46, 0x09, 0x22, 0xEA, 0x04, 0x63,
    0xFA, 0xB8, 0x6E, 0x0A, 0x11, 0x83, 0xF1, 0x06, 0x34, 0xF6, 0x8C, 0x66, 0x40, 0xAB, 0xF9, 0xD5,
    0x0F, 0xB6, 0x06, 0x0F, 0x23, 0x99, 0xDE, 0xAF, 0xC4, 0x64, 0x11, 0x87, 0xE3, 0x06, 0x6D, 0x37,
    0x83, 0x95, 0xD3, 0x78, 0xD7, 0xBA, 0x93, 0xF9, 0x37, 0x5E, 0x01, 0xE3, 0xF3, 0x52, 0x11, 0x35,
    0xB6, 0x22, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
])
ICON_STEP_FORWARD = bytes([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF,
    0x61, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
    0x00, 0xE0, 0x49, 0x44, 0x41, 0x54, 0x38, 0x4F, 0x63, 0x64, 0x40, 0x03, 0x22, 0xF2, 0x55, 0x92,
    0x6F, 0x1E, 0xB6, 0x3D, 0x47, 0x17, 0xC7, 0xC5, 0x67, 0x44, 0x97, 0x10, 0x56, 0xAC, 0xDC, 0xFF,
    0x9F, 0x81, 0x71, 0xE9, 0xBB, 0xFB, 0x6D, 0x73, 0xB0, 0x69, 0x12, 0x52, 0xAA, 0x6A, 0x78, 0x77,
    0xAF, 0xAD, 0x01, 0x26, 0x87, 0x69, 0x80, 0x52, 0xD5, 0x7F, 0x88, 0xE4, 0xFF, 0xAE, 0xB7, 0xF7,
    0xDA, 0xCB, 0x91, 0x0D, 0x11, 0x51, 0xA8, 0x70, 0xF8, 0xCF, 0xC4, 0xB4, 0xFF, 0xED, 0xBD, 0x36,
    0xB8, 0x3E, 0x3C, 0x06, 0x80, 0xB5, 0xAE, 0xE3, 0xFC, 0xF5, 0x3D, 0xE6, 0xC9, 0x93, 0xFE, 0xEF,
    0x20, 0x0E, 0x39, 0x06, 0x30, 0x30, 0x32, 0x30, 0x5C, 0xFA, 0xFB, 0x9F, 0x21, 0xF6, 0xFD, 0xFD,
    0xB6, 0x4B, 0x64, 0x19, 0x00, 0xF5, 0xC2, 0x77, 0x06, 0x86, 0xFF, 0x31, 0x8C, 0xFF, 0xFE, 0xBF,
    0x23, 0xD5, 0x0B, 0xA8, 0xE1, 0xC8, 0xC8, 0x58, 0xCE, 0xF0, 0xFF, 0x7F, 0x27, 0x29, 0x61, 0x80,
    0x35, 0xF6, 0x06, 0xCE, 0x00, 0x46, 0x46, 0x86, 0xB2, 0xFF, 0xFF, 0x19, 0xBA, 0xC8, 0x71, 0xC1,
    0x57, 0x26, 0x06, 0xA6, 0xB0, 0xFF, 0xFF, 0xFE, 0x7C, 0x23, 0x27, 0x10, 0x4F, 0x33, 0x31, 0x30,
    0x45, 0xBF, 0xBE, 0xD7, 0x72, 0x9B, 0x9C, 0x68, 0x5C, 0x20, 0xC8, 0x24, 0x91, 0x71, 0xE7, 0x4E,
    0xDE, 0x4F, 0x92, 0x13, 0xD2, 0x7F, 0x06, 0x86, 0x46, 0xE4, 0x34, 0x4F, 0xB4, 0x01, 0x22, 0x4A,
    0x55, 0xDB, 0xFE, 0x31, 0x30, 0xAD, 0x7E, 0x77, 0xAF, 0x65, 0x3E, 0x59, 0x99, 0x89, 0xD4, 0xEC,
    0x0C, 0x00, 0xF1, 0x38, 0x8E, 0x11, 0x4D, 0x2F, 0x76, 0x9D, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,
    0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
])
ICON_STEP_BLOCK = bytes([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF,
    0x61, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
    0x00, 0xA5, 0x49, 0x44, 0x41, 0x54, 0x38, 0x4F, 0x63, 0x64, 0xA0, 0x10, 0x30, 0x52, 0xA8, 0x9F,
    0x81, 0x3A, 0x06, 0x08, 0x2B, 0x56, 0xEE, 0x07, 0xB9, 0x84, 0xF1, 0xFF, 0xFF, 0x46, 0x10, 0xFD,
    0x9F, 0x91, 0xB1, 0x1E, 0x44, 0xBF, 0xBD, 0xDF, 0xEE, 0x28, 0xA4, 0x54, 0x55, 0xF8, 0xEE, 0x5E,
    0x5B, 0x3F, 0x2E, 0x97, 0x82, 0x5D, 0x00, 0x36, 0x80, 0x91, 0xD1, 0x81, 0xF1, 0xDF, 0x3F, 0x47,
    0xB0, 0x01, 0x4C, 0x4C, 0xFB, 0x19, 0xFE, 0xFF, 0x3F, 0x00, 0x32, 0x40, 0x58, 0xA9, 0xEA, 0x3F,
    0x03, 0x03, 0xE3, 0x16, 0x86, 0xFF, 0x0C, 0xCD, 0x6F, 0xEF, 0xB7, 0x9E, 0x42, 0x37, 0x88, 0x48,
    0x03, 0xC0, 0xDA, 0xBE, 0x31, 0x30, 0x30, 0xB4, 0xBC, 0xBD, 0xD7, 0xD6, 0x8E, 0x6C, 0x08, 0x29,
    0x06, 0x40, 0xF5, 0xFD, 0xDF, 0xF3, 0x8F, 0xE1, 0x5F, 0xE3, 0xFB, 0x7B, 0x9D, 0x47, 0xC0, 0xDE,
    0x26, 0xCE, 0x0B, 0x18, 0x21, 0xF0, 0xEF, 0x3F, 0xC3, 0xFF, 0xC6, 0x77, 0xF7, 0xDA, 0x9B, 0x06,
    0xC2, 0x00, 0xF2, 0xBD, 0x40, 0x49, 0x20, 0x12, 0x13, 0x8D, 0x94, 0x24, 0x24, 0x4A, 0xF2, 0x03,
    0x75, 0xF2, 0x02, 0x25, 0x2E, 0x00, 0x00, 0x2C, 0xE2, 0xAC, 0x11, 0x8B, 0xAB, 0xCA, 0x8B, 0x00,
    0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
])
ICON_STEP_TO = bytes([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF,
    0x61, 0x00, 0x00, 0x00, 0x01, 0x73, 0x52, 0x47, 0x42, 0x00, 0xAE, 0xCE, 0x1C, 0xE9, 0x00, 0x00,
    0x01, 0x25, 0x49, 0x44, 0x41, 0x54, 0x38, 0x4F, 0xA5, 0x93, 0x3D, 0x4E, 0xC4, 0x30, 0x10, 0x85,
    0xDF, 0xF8, 0x06, 0xC4, 0xA6, 0xDF, 0x8D, 0xF7, 0x00, 0xB4, 0x74, 0x29, 0x90, 0x80, 0x12, 0x21,
    0xA0, 0x81, 0x9E, 0x23, 0x04, 0x87, 0x22, 0x69, 0x52, 0x21, 0xD1, 0x41, 0x0F, 0x15, 0x3F, 0xA2,
    0x84, 0x82, 0x82, 0x93, 0xEC, 0x9E, 0x60, 0xB5, 0x0D, 0xB4, 0x78, 0x90, 0x2D, 0xB2, 0x32, 0xC6,
    0x09, 0x12, 0xEB, 0xCA, 0xF2, 0x8C, 0x3F, 0xCD, 0xCC, 0x7B, 0x43, 0x58, 0xF1, 0x90, 0xD2, 0xE6,
    0x6E, 0x3E, 0x6D, 0x8F, 0x62, 0x4E, 0x36, 0x31, 0xDB, 0xB0, 0xD8, 0x5C, 0xCC, 0xDA, 0x3A, 0x8E,
    0xAD, 0x8F, 0xCC, 0x86, 0x25, 0xBE, 0x74, 0xEF, 0x24, 0x73, 0xC3, 0x44, 0x78, 0x98, 0x4F, 0xDB,
    0xC3, 0x30, 0x51, 0xE6, 0xE5, 0x16, 0x20, 0x5E, 0x19, 0x68, 0x62, 0xC8, 0x9A, 0x36, 0xBB, 0x82,
    0xF1, 0xBC, 0x04, 0xF8, 0x4B, 0x04, 0x51, 0x93, 0xF3, 0x82, 0xAD, 0x7D, 0x73, 0xB1, 0x18, 0x92,
    0xE5, 0xD5, 0x3E, 0x81, 0x1F, 0x7F, 0x00, 0x62, 0x88, 0x1A, 0x95, 0x05, 0x0B, 0xE1, 0x01, 0xDF,
    0x90, 0x7A, 0x31, 0x6B, 0x1B, 0x77, 0x97, 0xE3, 0xB3, 0x13, 0x10, 0xDD, 0xFC, 0x02, 0x84, 0x90,
    0x18, 0x10, 0x42, 0x54, 0x5E, 0x9D, 0x32, 0xF8, 0x3A, 0x09, 0xE8, 0x20, 0xF8, 0xB4, 0x57, 0x61,
    0x05, 0x61, 0x25, 0x82, 0xF1, 0xC1, 0x84, 0x8B, 0x5E, 0x40, 0x07, 0x61, 0xC6, 0x41, 0x4A, 0x65,
    0x06, 0x6A, 0x02, 0xBC, 0x3A, 0x5E, 0x85, 0x54, 0x92, 0x1B, 0xEA, 0xBF, 0x01, 0xEE, 0xF3, 0x40,
    0x0B, 0x8D, 0x60, 0xBC, 0xF7, 0xB6, 0xD0, 0xC9, 0xD9, 0x33, 0x44, 0xEF, 0x89, 0xDE, 0x21, 0x86,
    0x5E, 0x48, 0xC8, 0xB8, 0x34, 0x94, 0x1C, 0x9B, 0x63, 0x10, 0x6E, 0x87, 0x8D, 0x14, 0xF8, 0x20,
    0x36, 0x92, 0xD4, 0xD5, 0x1E, 0x98, 0x9F, 0x06, 0xAD, 0xDC, 0x55, 0x90, 0xB2, 0x72, 0xA6, 0xCB,
    0x1D, 0x62, 0xF1, 0xE2, 0x01, 0x4A, 0x9B, 0xFB, 0x78, 0x0F, 0x5C, 0xC0, 0x01, 0xAC, 0x10, 0xC5,
    0x9F, 0xCB, 0xB4, 0xE2, 0x36, 0xE3, 0x0B, 0xA3, 0xD5, 0xB5, 0x11, 0x15, 0x4F, 0x31, 0x37, 0x00,
    0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
])


class ServiceStub(object):

    def __init__(self, server_addr):
        print("connect to server", server_addr)
        self._proxy = xmlrpc.client.ServerProxy(server_addr)

    def __del__(self):
        pass

    def eval(self, code):
        resp = self._proxy.eval(code)
        lines = resp.split("\n")
        for line in lines:
            print(line)
        return lines


class Emulator(object):
    def __init__(self):
        self._rpc = None

    def connect(self):
        self._rpc = ServiceStub(SEIDA_SERVER_ADDR)
        code = r"""
import angr
import claripy
import pickle

def dump_state(state):
    state = state  # type: angr.sim_state.SimState

    print("address: 0x%X" % state.addr)
    print("registers:")
    if project.arch.name == "AARCH64":
        reg_names = { 29: "fp", 30: "lr", 31: "sp", 32: "pc" }
        reg_count = 32
        reg_prefix = "x"
    else:
        reg_names = { 13: "sp", 14: "lr", 15: "pc" }
        reg_count = 15
        reg_prefix = "r"
    for i in range(0, reg_count + 1):
        r = reg_names[i] if i in reg_names else "%s%d" % (reg_prefix, i)
        print("%4s = %s " % (r, state.regs.get(r)), end="\n" if i != 0 and i % 6 == 0 else "")
    print("")

    sp = state.solver.eval(state.regs.get("sp"))
    stack_len = 0x50
    s = sp - stack_len
    print("stack memory:")
    hexdump(bytearray(state.mem[s].byte.array(stack_len).concrete), s)
    print("")  # empty line

def hexdump(buf, off=0):
    last_bs, last_line = None, None
    for i in range(0, len(buf), 16):
        bs = bytearray(buf[i : i + 16])
        line = "{:08x}  {:23}  {:23}  |{:16}|".format(
            off + i,
            " ".join(("{:02x}".format(x) for x in bs[:8])),
            " ".join(("{:02x}".format(x) for x in bs[8:])),
            "".join((chr(x) if 32 <= x < 127 else "." for x in bs)),
        )
        #if bs == last_bs:
        #    line = "*"
        if bs != last_bs or line != last_line:
            print(line)
        last_bs, last_line = bs, line
    print("{:08x}".format(off + len(buf)))
        """
        self._rpc.eval(code)

    def load(self, filename, base_addr=0):
        code = r"""
if "project" not in globals():  # always use the cache from globals
    if "{filename}".endswith(".dat"):
        with open("{filename}", "rb") as fp:
            project = pickle.load(fp)
    else:
        project = angr.Project("{filename}", main_opts={ "base_addr": {base_addr} })
print("deserialize project from file: %s" % "{filename}")
print("arch:", project.arch)
print("entry:", hex(project.entry))
print("filename:", project.filename)
print("loader:", project.loader)
print("objects:", project.loader.all_objects)
        """
        print("loading...", filename)
        code = code.replace("{filename}", filename)
        code = code.replace("{base_addr}", str(base_addr))
        self._rpc.eval(code)

    def start(self, start_addr):
        code = r"""
if "project" in globals():
    call_state = project.factory.call_state(addr={start_addr})
    call_state.options.add(angr.sim_options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    call_state.options.add(angr.sim_options.ZERO_FILL_UNCONSTRAINED_REGISTERS)

    simulation = project.factory.simulation_manager(call_state)
    print(simulation.active[0])
else:
    print("Error: not load any project")
        """
        code = code.replace("{start_addr}", str(start_addr))
        self._rpc.eval(code)

    @staticmethod
    def _get_addr_from_out(out, index=0):
        addr = -1
        if index >= 0 and len(out) > index:
            line = out[index]  # type: str
            m = re.match(r"address: 0x([A-Fa-f0-9]+)", line)
            if m:
                addr = int(m.group(1), base=16)
        else:
            for line in out:
                m = re.match(r"address: 0x([A-Fa-f0-9]+)", line)
                if m:
                    addr = int(m.group(1), base=16)
        return addr

    def step(self):
        code = r"""
simulation.step(num_inst=1)        
if len(simulation.active) > 0:
    dump_state(simulation.active[0])
else:
    print(simulation)
        """
        out = self._rpc.eval(code)
        return Emulator._get_addr_from_out(out)

    def step_block(self):
        code = r"""
simulation.step()        
if len(simulation.active) > 0:
    dump_state(simulation.active[0])
else:
    print(simulation)
        """
        out = self._rpc.eval(code)
        return Emulator._get_addr_from_out(out)

    def step_to(self, end_addr):
        code = r"""
while True:
    simulation.step(num_inst=1)
    if len(simulation.active) > 0:
        dump_state(simulation.active[0])
        if simulation.active[0].addr == {end_addr}:
            break
    else:
        print(simulation)
        break
        """
        code = code.replace("{end_addr}", str(end_addr))
        out = self._rpc.eval(code)
        return Emulator._get_addr_from_out(out, -1)

    def dump_memory(self, addr, len):
        code = r"""
if len(simulation.active) > 0:
    hexdump(bytearray(simulation.active[0].mem[{addr}].byte.array({len}).concrete), {addr})
else:
    print(simulation)
        """
        code = code.replace("{addr}", str(addr))
        code = code.replace("{len}", str(len))
        return self._rpc.eval(code)

    def set_reg(self, reg_name, val):
        reg_name = reg_name.lower()  # type: str
        size = 32 if reg_name.startswith("w") else 64
        code = r"""
import claripy
if len(simulation.active) > 0:
    simulation.active[0].regs.{reg_name} = claripy.BVV({val}, {size})
        """
        code = code.replace("{reg_name}", reg_name)
        code = code.replace("{val}", str(val))
        code = code.replace("{size}", str(size))
        return self._rpc.eval(code)

    def hook_func(self, addr):
        code = r"""
stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] 
project.hook({addr}, stub_func())
        """
        code = code.replace("{addr}", str(addr))
        return self._rpc.eval(code)

    def unhook_func(self, addr):
        code = r"""
project.unhook({addr})
        """
        code = code.replace("{addr}", str(addr))
        return self._rpc.eval(code)

    def do_file(self, filename):
        with open(filename, "r") as f:
            code = f.read()
            return self._rpc.eval(code)


class StepActionHandler(ida_kernwin.action_handler_t):

    def __init__(self, emulator):
        super().__init__()
        self._emulator = emulator

    def activate(self, ctx):
        #print("step_action_handler_t()", ctx.action, hex(ctx.cur_ea))
        ea = ctx.cur_ea
        is_thumb = idautils.DecodeInstruction(idc.here()).size == 2
        if is_thumb:
            ea += 1
        if ctx.action == START_EXEC_ACTION_NAME:
            self._emulator.start(ea)
        elif ctx.action == STEP_INST_ACTION_NAME:
            next_ea = self._emulator.step()
            if next_ea > 0:
                if is_thumb:
                    next_ea -= 1
                ida_kernwin.jumpto(next_ea)
        elif ctx.action == STEP_BLOCK_ACTION_NAME:
            next_ea = self._emulator.step_block()
            if next_ea > 0:
                if is_thumb:
                    next_ea -= 1
                ida_kernwin.jumpto(next_ea)
        elif ctx.action == STEP_TO_ACTION_NAME:
            next_ea = self._emulator.step_to(ea)
            if next_ea > 0:
                if is_thumb:
                    next_ea -= 1
                ida_kernwin.jumpto(next_ea)

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_FOR_WIDGET if ctx.widget_type == ida_kernwin.BWN_DISASM else ida_kernwin.AST_DISABLE_FOR_WIDGET


class SeidaPlugin(ida_idaapi.plugin_t, ida_kernwin.action_handler_t):

    def __init__(self):
        self._emulator = None
        self._start_icon = None
        self._step_icon = None
        self._stepb_icon = None
        self._stept_icon = None
        self._action_handler = None

    def init(self):
        global seida
        seida = self
        self._emulator = Emulator()
        self._emulator.connect()
        self._start_icon = ida_kernwin.load_custom_icon(data=ICON_START, format="png")
        self._step_icon = ida_kernwin.load_custom_icon(data=ICON_STEP_FORWARD, format="png")
        self._stepb_icon = ida_kernwin.load_custom_icon(data=ICON_STEP_BLOCK, format="png")
        self._stept_icon = ida_kernwin.load_custom_icon(data=ICON_STEP_TO, format="png")
        self._action_handler = StepActionHandler(self._emulator)

        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(START_EXEC_ACTION_NAME, "start", self._action_handler, None, "start execution",
                                      self._start_icon))
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(STEP_INST_ACTION_NAME, "step", self._action_handler, None, "step",
                                      self._step_icon))
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(STEP_BLOCK_ACTION_NAME, "stepb", self._action_handler, None, "step block",
                                      self._stepb_icon))
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(STEP_TO_ACTION_NAME, "stept", self._action_handler, None, "step to",
                                      self._stept_icon))

        ida_kernwin.attach_action_to_toolbar("AnalysisToolBar", START_EXEC_ACTION_NAME)
        ida_kernwin.attach_action_to_toolbar("AnalysisToolBar", STEP_INST_ACTION_NAME)
        ida_kernwin.attach_action_to_toolbar("AnalysisToolBar", STEP_BLOCK_ACTION_NAME)
        ida_kernwin.attach_action_to_toolbar("AnalysisToolBar", STEP_TO_ACTION_NAME)
        print("seida inited")

    def term(self):
        self._action_handler = None
        if self._start_icon:
            ida_kernwin.free_custom_icon(self._start_icon)
        if self._step_icon:
            ida_kernwin.free_custom_icon(self._step_icon)
        if self._stepb_icon:
            ida_kernwin.free_custom_icon(self._stepb_icon)
        if self._stept_icon:
            ida_kernwin.free_custom_icon(self._stept_icon)

        ida_kernwin.unregister_action(START_EXEC_ACTION_NAME)
        ida_kernwin.unregister_action(STEP_INST_ACTION_NAME)
        ida_kernwin.unregister_action(STEP_BLOCK_ACTION_NAME)
        ida_kernwin.unregister_action(STEP_TO_ACTION_NAME)

        ida_kernwin.detach_action_from_toolbar("AnalysisToolBar", START_EXEC_ACTION_NAME)
        ida_kernwin.detach_action_from_toolbar("AnalysisToolBar", STEP_INST_ACTION_NAME)
        ida_kernwin.detach_action_from_toolbar("AnalysisToolBar", STEP_BLOCK_ACTION_NAME)
        ida_kernwin.detach_action_from_toolbar("AnalysisToolBar", STEP_TO_ACTION_NAME)

    def run(self):
        pass

    def __getattr__(self, attr):
        if hasattr(self._emulator, attr):  # as proxy of emulator
            return getattr(self._emulator, attr)
        return None


def PLUGIN_ENTRY():
    return SeidaPlugin()


def main():
    global seida
    seida = SeidaPlugin()
    seida.term()
    seida.init()
    seida.run()


if SEIDA_USE_AS_SCRIPT and __name__ == "__main__":
    main()
